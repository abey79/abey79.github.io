<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Annotated Release Notes: vpype 1.11 | bylr.info</title>
<meta name=keywords content="vpype,plotter">
<meta name=description content="This release further solidifies the block commands which were overhauled in vpype 1.9. It also introduces several changes revolving around the &ldquo;plotting with paint&rdquo; use-case, which typically requires the brush to be regularly dipped in a paint well. This can be achieved by inserting &ldquo;dipping&rdquo; patterns at regular intervals determined by the cumulative drawing distance. vpype 1.11 makes this process much easier.
Thanks a lot to Andee Collard for his useful feedback and providing this article&rsquo;s banner!">
<meta name=author content>
<link rel=canonical href=https://bylr.info/articles/2022/07/06/annotated-release-notes-vpype-1.11/>
<link crossorigin=anonymous href=/assets/css/stylesheet.6c6bbb0265bd99a430fed22493ed8a614c025b8b6da7f1f7b07910f023f53da8.css integrity="sha256-bGu7AmW9maQw/tIkk+2KYUwCW4ttp/H3sHkQ8CP1Pag=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bylr.info/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://bylr.info/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://bylr.info/favicon-32x32.png>
<link rel=apple-touch-icon href=https://bylr.info/apple-touch-icon.png>
<link rel=mask-icon href=https://bylr.info/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript><script defer data-domain=bylr.info data-api=https://sta.abeyeler.workers.dev/sta/event src=https://sta.abeyeler.workers.dev/sta/script.js></script><meta property="og:title" content="Annotated Release Notes: vpype 1.11">
<meta property="og:description" content="This release further solidifies the block commands which were overhauled in vpype 1.9. It also introduces several changes revolving around the &ldquo;plotting with paint&rdquo; use-case, which typically requires the brush to be regularly dipped in a paint well. This can be achieved by inserting &ldquo;dipping&rdquo; patterns at regular intervals determined by the cumulative drawing distance. vpype 1.11 makes this process much easier.
Thanks a lot to Andee Collard for his useful feedback and providing this article&rsquo;s banner!">
<meta property="og:type" content="article">
<meta property="og:url" content="https://bylr.info/articles/2022/07/06/annotated-release-notes-vpype-1.11/">
<meta property="og:image" content="https://bylr.info/vpype_111/banner.jpg"><meta property="article:section" content="articles">
<meta property="article:published_time" content="2022-07-06T00:00:00+00:00">
<meta property="article:modified_time" content="2022-07-06T00:00:00+00:00"><meta property="og:site_name" content="Antoine Beyeler">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://bylr.info/vpype_111/banner.jpg">
<meta name=twitter:title content="Annotated Release Notes: vpype 1.11">
<meta name=twitter:description content="This release further solidifies the block commands which were overhauled in vpype 1.9. It also introduces several changes revolving around the &ldquo;plotting with paint&rdquo; use-case, which typically requires the brush to be regularly dipped in a paint well. This can be achieved by inserting &ldquo;dipping&rdquo; patterns at regular intervals determined by the cumulative drawing distance. vpype 1.11 makes this process much easier.
Thanks a lot to Andee Collard for his useful feedback and providing this article&rsquo;s banner!">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://bylr.info/articles/"},{"@type":"ListItem","position":2,"name":"Annotated Release Notes: vpype 1.11","item":"https://bylr.info/articles/2022/07/06/annotated-release-notes-vpype-1.11/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Annotated Release Notes: vpype 1.11","name":"Annotated Release Notes: vpype 1.11","description":"This release further solidifies the block commands which were overhauled in vpype 1.9. It also introduces several changes revolving around the \u0026ldquo;plotting with paint\u0026rdquo; use-case, which typically requires the brush to be regularly dipped in a paint well. This can be achieved by inserting \u0026ldquo;dipping\u0026rdquo; patterns at regular intervals determined by the cumulative drawing distance. vpype 1.11 makes this process much easier.\nThanks a lot to Andee Collard for his useful feedback and providing this article\u0026rsquo;s banner!","keywords":["vpype","plotter"],"articleBody":"This release further solidifies the block commands which were overhauled in vpype 1.9. It also introduces several changes revolving around the “plotting with paint” use-case, which typically requires the brush to be regularly dipped in a paint well. This can be achieved by inserting “dipping” patterns at regular intervals determined by the cumulative drawing distance. vpype 1.11 makes this process much easier.\nThanks a lot to Andee Collard for his useful feedback and providing this article’s banner!\nPainting with a plotter  Added the splitdist command to split layers by drawing distance (thanks to @LoicGoulefert) (#487, #501)   The new splitdist command, contributed by Loïc Goulefert (thanks a lot!), is the core of the paint plotting use-case. It splits each layer into newly created layers such that their respective drawing distance is each below the specified limit.\nThis command could readily be used with a clever vpype-gcode profile that implements the dipping mechanism at the beginning of each layer. Alternatively, it can be combined with the forlayer block command to insert dipping patterns into the line work. We’ll see an example of such a pipeline below.\n Added meters (m) and feet (ft) to the supported units (#498, #508) Fixed an issue with expressions where some variable names corresponding to units (e.g. m) could not be used (expressions may now reuse these names) (#506)   These are rather large units for typical plotting workflow, but come in useful for specifying the maximum drawing distance with splitdist.\nAs a reminder, units are available in two contexts:\n Every time a command accepts a length-type argument or option (e.g. translate 5mm 3cm or linemerge --tolerance 0.05mm). In expressions (e.g. forlayer translate \"%_i*3*cm%\" 0 end).  In the latter case, the existence of the unit constant precluded the use of variables with the same name. This issue worsened with the addition of m as this is a rather common variable name (e.g. this cookbook recipe uses it). To address this, they are no longer read-only and may now be overwritten. Of course, doing so renders their original value unavailable in the pipeline’s subsequent expressions.\n Fixed an issue with blocks where certain nested commands could lead totally unexpected results (#506) API: removed the faulty temp_document() context manager from vpype_cli.State() (#506)   The improved blocks introduced in vpype 1.9 had a major flaw which could, in some circumstances, result in erratic results. It turns out that the new splitdist command triggered this issue and brought it in the spotlight. This is now fixed, and the vpype_cli.State.temp_document() API is a casualty of this patch (luckily, it was introduced recently and I’m pretty sure no one used it yet besides me).\n Fixed an issue with the lmove command where order would not be respected in certain cases such as lmove all 2 (the content of layer 2 was placed before that of layer 1) (#506)   This is yet another issue highlighted by to the “plotting with paint” workflow. When the source layers included the destination layer (as is the case for lmove all 2), the order of the source layers would not be respected (e.g. for a 3-layer pipeline and thelmove all 2 command, layer 2 would end up with its original content, then layer 1, then layer 3). With this fix, the destination layer will now include the source layers' content in the correct order (e.g. in the previous example, layer 2 would end up with the content of layer 1, then layer 2, then layer 3).\n Collectively, these changes enable the “plotting with paint” workflow using the following pipeline:\n$ vpype \\  read input.svg \\  forlayer \\  lmove %_lid% 1 \\  splitdist 1m \\  forlayer \\  lmove %_lid% \"%_lid*2%\" \\  read -l \"%_lid*2-1%\" dip_%_name%.svg \\  end \\  lmove all %_lid% \\  name -l %_lid% %_name% \\  color -l %_lid% %_color% \\  end \\  write output.svg For this to work, the layers in input.svg must be named after their respective color and, for each such color, a file named dip_COLORNAME.svg must exist. For example, if input.svg has two layers named “red” and “blue”, then the dip_red.svg and dip_blue.svg files must exist.\nThe following figure illustrates the results for synthetic data.\n (left) Input SVG with 3 layers. (middle) The three corresponding dipping pattern SVGs. (right) The output SVG with 3 layers and the visible dipping patterns interspersed within the line work.\n  This pipeline is listed in a cookbook recipe and will be explained in details, along with the forlayer block command, in a future article.\nOther changes  Improved the linemerge algorithm by making it less dependent on line order (#496)   The linemerge command is implemented using a greedy algorithm which roughly works as follows:\n Pick the first available line. Look for another line that can be appended. If found, merge both lines and look for further line to append (back to step 2). If not, save the current line, pick the next available one, and repeat (back to step 1).  By default, linemerge always considers both endings of each line, possibly reversing them if this enables a merge. This is not always desirable though, which is why the --no-flip option exists. In this case, the algorithm would only try to append to the current line, without trying to prepend as well. This oversight led to a greater dependence on line order and, occasionally, suboptimal results, as illustrated by the figure below.\n  (left) Initial situation. (middle) Result when both appending only. (right) Results when appending and prepending.\n  With this fix, linemerge --no-flip now tries to both append and prepend, leading to more consistent results.\n Added --keep-page-size option to grid command (#506)   By default, the grid block command sets the page size to its geometry. For example, the block grid --offset 4cm 3cm 3 5 [...] end sets the page size to 12x15cm. This behaviour can now be disabled with the --keep-page-size option.\nThis change mainly helps for the testability of the blocks feature (in this release, I’ve added multiple tests to minimise the risk of future regression), but I figured it could have its occasional use out there.\n Added HPGL configurations for the Houston Instrument DMP-161, HP7550, Roland DXY 1xxxseries and sketchmate plotters (thanks to @jimmykl and @ithinkido) (#472, #474)   Thanks a lot, Jimmy Kirkus-Lamont and @ithinkido! ❤️\n Added equality operator to vpype.LineCollection and vpype.Document (#506)   I can now check if two layers or documents have the same content and metadata using the equality operator ==. This is immensely useful when writing tests. I have no idea why it took so long… 🤷\n Pinned Shapely to 1.8.2, which is the first release in a long time to have binaries for most platforms/Python release combination (including Apple-silicon Macs and Python 3.10) (#475)   It was quite the roller coaster ride for Shapely to be properly packaged for both Python 3.10 and Apple-silicon Macs, but now this is fully sorted out. That’s one less hassle when installing vpype.\n Removed deprecated API (#507)   With vpype 1.9, a number of APIs migrated from the vpype package to the vpype_cli package. The former APIs still worked but emitted deprecation warnings. They are now gone forever.\n","wordCount":"1174","inLanguage":"en","image":"https://bylr.info/vpype_111/banner.jpg","datePublished":"2022-07-06T00:00:00Z","dateModified":"2022-07-06T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bylr.info/articles/2022/07/06/annotated-release-notes-vpype-1.11/"},"publisher":{"@type":"Organization","name":"bylr.info","logo":{"@type":"ImageObject","url":"https://bylr.info/favicon.ico"}}}</script>
</head>
<body id=top>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://bylr.info/ accesskey=h title="bylr.info (Alt + H)">bylr.info</a>
<div class=logo-switches>
</div>
</div>
<ul id=menu>
<li>
<a href=https://bylr.info/about/ title=about>
<span>about</span>
</a>
</li>
<li>
<a href=https://bylr.info/archives title=archives>
<span>archives</span>
</a>
</li>
<li>
<a href=https://bylr.info/tags/ title=tags>
<span>tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Annotated Release Notes: vpype 1.11
</h1>
<div class=post-meta><span title="2022-07-06 00:00:00 +0000 UTC">July 6, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/abey79/abey79.github.io/blob/main/content/articles/vpype-1.11.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://bylr.info/vpype_111/banner.jpg alt="plotting with paint using vpype 1.11">
</figure>
<div class=post-content><p>This release further solidifies the block commands which were overhauled in <a href=/articles/2022/03/03/annotated-release-notes-vpype-1.9/><em>vpype</em> 1.9</a>. It also introduces several changes revolving around the &ldquo;plotting with paint&rdquo; use-case, which typically requires the brush to be regularly dipped in a paint well. This can be achieved by inserting &ldquo;dipping&rdquo; patterns at regular intervals determined by the cumulative drawing distance. <em>vpype</em> 1.11 makes this process much easier.</p>
<p>Thanks a lot to <a href=https://www.andeecollard.com/>Andee Collard</a> for his useful feedback and providing this article&rsquo;s banner!</p>
<h2 id=painting-with-a-plotter>Painting with a plotter<a hidden class=anchor aria-hidden=true href=#painting-with-a-plotter>#</a></h2>
<blockquote class=extract>
<p><ul>
<li>Added the <code>splitdist</code> command to split layers by drawing distance (thanks to @LoicGoulefert) (#487, #501)</li>
</ul>
</p>
</blockquote>
<p>The new <a href=https://vpype.readthedocs.io/en/latest/reference.html#splitdist><code>splitdist</code></a> command, contributed by <a href=https://compotedeplot.bigcartel.com>Loïc Goulefert</a> (thanks a lot!), is the core of the paint plotting use-case. It splits each layer into newly created layers such that their respective drawing distance is each below the specified limit.</p>
<p>This command could readily be used with a clever <a href=https://github.com/plottertools/vpype-gcode>vpype-gcode</a> profile that implements the dipping mechanism at the beginning of each layer. Alternatively, it can be combined with the <code>forlayer</code> block command to insert dipping patterns into the line work. We&rsquo;ll see an example of such a pipeline below.</p>
<blockquote class=extract>
<p><ul>
<li>Added meters (<code>m</code>) and feet (<code>ft</code>) to the supported units (#498, #508)</li>
<li>Fixed an issue with expressions where some variable names corresponding to units (e.g. <code>m</code>) could not be used (expressions may now reuse these names) (#506)</li>
</ul>
</p>
</blockquote>
<p>These are rather large units for typical plotting workflow, but come in useful for specifying the maximum drawing distance with <code>splitdist</code>.</p>
<p>As a reminder, units are available in two contexts:</p>
<ol>
<li>Every time a command accepts a length-type argument or option (e.g. <code>translate 5mm 3cm</code> or <code>linemerge --tolerance 0.05mm</code>).</li>
<li>In <a href=https://vpype.readthedocs.io/en/latest/fundamentals.html#built-in-symbols>expressions</a> (e.g. <code>forlayer translate "%_i*3*cm%" 0 end</code>).</li>
</ol>
<p>In the latter case, the existence of the unit constant precluded the use of variables with the same name. This issue worsened with the addition of <code>m</code> as this is a rather common variable name (e.g. this cookbook <a href=https://vpype.readthedocs.io/en/latest/cookbook.html#cropping-and-framing-geometries>recipe</a> uses it). To address this, they are no longer read-only and may now be overwritten. Of course, doing so renders their original value unavailable in the pipeline&rsquo;s subsequent expressions.</p>
<blockquote class=extract>
<p><ul>
<li>Fixed an issue with blocks where certain nested commands could lead totally unexpected results (#506)</li>
<li>API: removed the faulty <code>temp_document()</code> context manager from <code>vpype_cli.State()</code> (#506)</li>
</ul>
</p>
</blockquote>
<p>The improved blocks introduced in <a href=/articles/2022/03/03/annotated-release-notes-vpype-1.9/><em>vpype</em> 1.9</a> had a major flaw which could, in some circumstances, result in erratic results. It turns out that the new <code>splitdist</code> command triggered this issue and brought it in the spotlight. This is now fixed, and the <code>vpype_cli.State.temp_document()</code> API is a casualty of this patch (luckily, it was introduced recently and I&rsquo;m pretty sure no one used it yet besides me).</p>
<blockquote class=extract>
<p><ul>
<li>Fixed an issue with the <code>lmove</code> command where order would not be respected in certain cases such as <code>lmove all 2</code> (the content of layer 2 was placed before that of layer 1) (#506)</li>
</ul>
</p>
</blockquote>
<p>This is yet another issue highlighted by to the &ldquo;plotting with paint&rdquo; workflow. When the source layers included the destination layer (as is the case for <code>lmove all 2</code>), the order of the source layers would not be respected (e.g. for a 3-layer pipeline and the<code>lmove all 2</code> command, layer 2 would end up with its original content, then layer 1, then layer 3). With this fix, the destination layer will now include the source layers' content in the correct order (e.g. in the previous example, layer 2 would end up with the content of layer 1, then layer 2, then layer 3).</p>
<br>
<p>Collectively, these changes enable the &ldquo;plotting with paint&rdquo; workflow using the following pipeline:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ vpype <span style=color:#d14>\
</span><span style=color:#d14></span>      <span style=color:#0086b3>read</span> input.svg <span style=color:#d14>\
</span><span style=color:#d14></span>      forlayer <span style=color:#d14>\
</span><span style=color:#d14></span>        lmove %_lid% <span style=color:#099>1</span> <span style=color:#d14>\
</span><span style=color:#d14></span>        splitdist 1m <span style=color:#d14>\
</span><span style=color:#d14></span>        forlayer <span style=color:#d14>\
</span><span style=color:#d14></span>          lmove %_lid% <span style=color:#d14>&#34;%_lid*2%&#34;</span> <span style=color:#d14>\
</span><span style=color:#d14></span>          <span style=color:#0086b3>read</span> -l <span style=color:#d14>&#34;%_lid*2-1%&#34;</span> dip_%_name%.svg <span style=color:#d14>\
</span><span style=color:#d14></span>        end <span style=color:#d14>\
</span><span style=color:#d14></span>      lmove all %_lid% <span style=color:#d14>\
</span><span style=color:#d14></span>      name -l %_lid% %_name% <span style=color:#d14>\
</span><span style=color:#d14></span>      color -l %_lid% %_color% <span style=color:#d14>\
</span><span style=color:#d14></span>    end <span style=color:#d14>\
</span><span style=color:#d14></span>    write output.svg
</code></pre></div><p>For this to work, the layers in <code>input.svg</code> must be named after their respective color and, for each such color, a file named <code>dip_COLORNAME.svg</code> must exist. For example, if <code>input.svg</code> has two layers named &ldquo;red&rdquo; and &ldquo;blue&rdquo;, then the <code>dip_red.svg</code> and <code>dip_blue.svg</code> files must exist.</p>
<p>The following figure illustrates the results for synthetic data.</p>
<figure class=square-corner>
<img loading=lazy src=/vpype_111/paint_workflow.svg alt="(left) Input SVG with 3 layers. (middle) The three corresponding dipping pattern SVGs. (right) The output SVG with 3 layers and the visible dipping patterns interspersed within the line work."> <figcaption>
<p>(<em>left</em>) Input SVG with 3 layers. (<em>middle</em>) The three corresponding dipping pattern SVGs. (<em>right</em>) The output SVG with 3 layers and the visible dipping patterns interspersed within the line work.</p>
</figcaption>
</figure>
<p>This pipeline is listed in a cookbook <a href=https://vpype.readthedocs.io/en/latest/cookbook.html#inserting-regular-dipping-patterns-for-plotting-with-paint>recipe</a> and will be explained in details, along with the <code>forlayer</code> block command, in a future article.</p>
<h2 id=other-changes>Other changes<a hidden class=anchor aria-hidden=true href=#other-changes>#</a></h2>
<blockquote class=extract>
<p><ul>
<li>Improved the <code>linemerge</code> algorithm by making it less dependent on line order (#496)</li>
</ul>
</p>
</blockquote>
<p>The <code>linemerge</code> command is implemented using a <a href=https://en.wikipedia.org/wiki/Greedy_algorithm>greedy</a> algorithm which roughly works as follows:</p>
<ol>
<li>Pick the first available line.</li>
<li>Look for another line that can be appended.</li>
<li>If found, merge both lines and look for further line to append (back to step 2). If not, save the current line, pick the next available one, and repeat (back to step 1).</li>
</ol>
<p>By default, <code>linemerge</code> always considers both endings of each line, possibly reversing them if this enables a merge. This is not always desirable though, which is why the <code>--no-flip</code> option exists. In this case, the algorithm would only try to <em>append</em> to the current line, without trying to <em>prepend</em> as well. This oversight led to a greater dependence on line order and, occasionally, suboptimal results, as illustrated by the figure below.</p>
<figure>
<img loading=lazy src=/vpype_111/linemerge.svg alt="(left) Initial situation. (middle) Result when both appending only. (right) Results when appending and prepending."> <figcaption>
<p>(<em>left</em>) Initial situation. (<em>middle</em>) Result when both appending only. (<em>right</em>) Results when appending and prepending.</p>
</figcaption>
</figure>
<p>With this fix, <code>linemerge --no-flip</code> now tries to both append and prepend, leading to more consistent results.</p>
<blockquote class=extract>
<p><ul>
<li>Added <code>--keep-page-size</code> option to <code>grid</code> command (#506)</li>
</ul>
</p>
</blockquote>
<p>By default, the <code>grid</code> block command sets the page size to its geometry. For example, the block <code>grid --offset 4cm 3cm 3 5 [...] end</code> sets the page size to 12x15cm. This behaviour can now be disabled with the <code>--keep-page-size</code> option.</p>
<p>This change mainly helps for the testability of the blocks feature (in this release, I&rsquo;ve added multiple tests to minimise the risk of future regression), but I figured it could have its occasional use out there.</p>
<blockquote class=extract>
<p><ul>
<li>Added HPGL configurations for the Houston Instrument DMP-161, HP7550, Roland DXY 1xxxseries and sketchmate plotters (thanks to @jimmykl and @ithinkido) (#472, #474)</li>
</ul>
</p>
</blockquote>
<p>Thanks a lot, <a href=https://linktr.ee/jimmyis>Jimmy Kirkus-Lamont</a> and <a href=https://github.com/ithinkido>@ithinkido</a>! ❤️</p>
<blockquote class=extract>
<p><ul>
<li>Added equality operator to <code>vpype.LineCollection</code> and <code>vpype.Document</code> (#506)</li>
</ul>
</p>
</blockquote>
<p>I can now check if two layers or documents have the same content and metadata using the equality operator <code>==</code>. This is immensely useful when writing tests. I have no idea why it took so long… 🤷</p>
<blockquote class=extract>
<p><ul>
<li>Pinned Shapely to 1.8.2, which is the first release in a long time to have binaries for most platforms/Python release combination (including Apple-silicon Macs and Python 3.10) (#475)</li>
</ul>
</p>
</blockquote>
<p>It was quite the roller coaster ride for <a href=https://shapely.readthedocs.io/>Shapely</a> to be properly packaged for both Python 3.10 and Apple-silicon Macs, but now this is fully sorted out. That&rsquo;s one less hassle when installing <em>vpype</em>.</p>
<blockquote class=extract>
<p><ul>
<li>Removed deprecated API (#507)</li>
</ul>
</p>
</blockquote>
<p>With <a href=/articles/2022/03/03/annotated-release-notes-vpype-1.9/><em>vpype</em> 1.9</a>, a number of APIs migrated from the <code>vpype</code> package to the <code>vpype_cli</code> package. The former APIs still worked but emitted <a href=/articles/2022/03/03/annotated-release-notes-vpype-1.9/#other-changes>deprecation warnings</a>. They are now gone forever.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://bylr.info/tags/vpype/>vpype</a></li>
<li><a href=https://bylr.info/tags/plotter/>plotter</a></li>
</ul>
</footer><script src=https://utteranc.es/client.js repo=abey79/abey79.github.io issue-term=pathname label=comments theme=github-light crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>© 2022-2023 Antoine Beyeler –</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerHTML='copy';function d(){a.innerHTML='copied!',setTimeout(()=>{a.innerHTML='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>